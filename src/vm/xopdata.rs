//!
//! Xtended/Xtra Operations based Data
//! HanishKVC, 2022
//!

use std::time;

use rand::Rng;

use crate::datautils;
use super::{DataM, Context, datas::{VDataType, Variant}};


#[derive(Debug, Clone)]
pub(crate) enum XOpData {
    /// Returns the passed data after convertion into a textual string
    Str(Box<DataM>),
    /// Returns the given data after convertion into a hexadecimal textual string
    StrHex(Box<DataM>),
    /// Return the given data after trimming any whitespace at either end
    StrTrim(Box<DataM>),
    /// Retrieve the byte value at the given byte offset of the passed data
    ByteEle(Box<DataM>, Box<DataM>),
    /// Retrieve the element at given offset of the passed data
    /// Useful for getting char from a string, or a array element or so...
    ArrayEle(Box<DataM>, Box<DataM>),
    /// Get a representation of the current date-time
    TimeStamp,
    /// Get a bunch of random data
    RandomBytes(Box<DataM>),
}

impl XOpData {

    pub fn identify(&self) -> String {
        match self {
            Self::Str(dm) => format!("!Str({})", dm.identify()),
            Self::StrTrim(dm) => format!("!StrTrim({})", dm.identify()),
            Self::StrHex(dm) => format!("!StrHex({})", dm.identify()),
            Self::ByteEle(dm, index) => format!("!ByteEle({}, {})", dm.identify(), index.identify()),
            Self::ArrayEle(ddm, idm) => format!("!ArrayEle({}, {})", ddm.identify(), idm.identify()),
            XOpData::TimeStamp => format!("TimeStamp"),
            XOpData::RandomBytes(dm) => format!("!RandomBytes({})", dm.identify()),
        }
    }

    /// * XTimeStamp returns current System time converted to milliseconds since UNIX Epoch, as a string
    /// * XRandomBytes returns random generated bytes converted to string using utf8_lossy
    pub fn get_string(&self, ctxt: &mut Context) -> Result<String, String> {
        match self {
            Self::Str(dm) => {
                let tv = dm.get_type_value(ctxt);
                if tv.is_err() {
                    return Err(format!("XOpData:Str:GetString:{:?}:{}", self, tv.unwrap_err()));
                }
                let (vtype, vvalue) = tv.unwrap();
                match vtype {
                    VDataType::Buffer => return Ok(String::from_utf8_lossy(&vvalue.get_bufvu8()).to_string()),
                    _ => return Ok(vvalue.get_string()),
                }
            }
            Self::StrTrim(dm) => {
                let tv = dm.get_type_value(ctxt);
                if tv.is_err() {
                    return Err(format!("XOpData:StrTrim:GetString:{:?}:{}", self, tv.unwrap_err()));
                }
                let (vtype, vvalue) = tv.unwrap();
                let sdata = match vtype {
                    VDataType::Buffer => String::from_utf8_lossy(&vvalue.get_bufvu8()).to_string(),
                    _ => vvalue.get_string(),
                };
                return Ok(sdata.trim().to_string());
            }
            Self::StrHex(dm) => {
                let bdata = dm.get_bufvu8(ctxt);
                if bdata.is_err() {
                    return Err(format!("XOpData:StrHex:GetString:{:?}:{}", self, bdata.unwrap_err()));
                }
                return Ok(datautils::hex_from_vu8(&bdata.unwrap()));
            }
            Self::ByteEle(dm, index) => {
                let i = index.get_usize(ctxt);
                if i.is_err() {
                    return Err(format!("XOpData:ByteEle:GetString:{:?}:GetIndex:{}", self, i.unwrap_err()));
                }
                let bval = dm.get_byteelement(ctxt, i.unwrap());
                if bval.is_err() {
                    return Err(format!("XOpData:ByteEle:GetString:{:?}:IndexedData:{}", self, bval.unwrap_err()));
                }
                let cval = char::from_u32( bval.unwrap() as u32).unwrap();
                return Ok(cval.to_string());
            }
            Self::ArrayEle(ddm, idm) => {
                let i = idm.get_usize(ctxt);
                if i.is_err() {
                    return Err(format!("XOpData:ArrayEle:GetString:{:?}:GetIndex:{}", self, i.unwrap_err()));
                }
                let vval = ddm.get_arrayelement(ctxt, i.unwrap());
                if vval.is_err() {
                    return Err(format!("XOpData:ArrayEle:GetString:{:?}:IndexedData:{}", self, vval.unwrap_err()));
                }
                return Ok(vval.unwrap().get_string());
            }
            Self::TimeStamp => {
                let ts = time::SystemTime::now().duration_since(time::UNIX_EPOCH).unwrap();
                let uts = ts.as_millis();
                return Ok(uts.to_string());
            },
            Self::RandomBytes(_bytelen) => {
                let vdata = self.get_bufvu8(ctxt);
                if vdata.is_err() {
                    return Err(format!("XOpData:GetString:{:?}:{}", self, vdata.unwrap_err()));
                }
                let vdata = vdata.unwrap();
                return Ok(String::from_utf8_lossy(&vdata).to_string());
            }

        }
    }

    /// * XTimeStamp -> milliseconds from UnixEpoch truncated
    /// * XRandomBytes -> a randomly generated Int (limited to min(Int size,requested bytes))
    pub fn get_isize(&self, ctxt: &mut Context) -> Result<isize, String> {
        match self {
            Self::ByteEle(dm, index) => {
                let i = index.get_usize(ctxt);
                if i.is_err() {
                    return Err(format!("XOpData:GetISize:{:?}:GetIndex:{}", self, i.unwrap_err()));
                }
                let bval = dm.get_byteelement(ctxt, i.unwrap());
                if bval.is_err() {
                    return Err(format!("XOpData:GetISize:{:?}:IndexedData:{}", self, bval.unwrap_err()));
                }
                return Ok(bval.unwrap() as isize);
            }
            Self::ArrayEle(ddm, idm) => {
                let i = idm.get_usize(ctxt);
                if i.is_err() {
                    return Err(format!("XOpData:GetISize:{:?}:GetIndex:{}", self, i.unwrap_err()));
                }
                let vval = ddm.get_arrayelement(ctxt, i.unwrap());
                if vval.is_err() {
                    return Err(format!("XOpData:GetISize:{:?}:IndexedData:{}", self, vval.unwrap_err()));
                }
                let ival = vval.unwrap().get_isize();
                if ival.is_err() {
                    return Err(format!("XOpData:GetISize:{:?}:Value:{}", self, ival.unwrap_err()));
                }
                return Ok(ival.unwrap());
            }
            Self::TimeStamp => {
                let ts = time::SystemTime::now().duration_since(time::UNIX_EPOCH).unwrap();
                let uts = ts.as_millis();
                return Ok(uts as isize);
            }
            Self::RandomBytes(_bytelen) => {
                let vdata = self.get_bufvu8(ctxt);
                if vdata.is_err() {
                    return Err(format!("XOpData:GetISize:{:?}:{}", self, vdata.unwrap_err()));
                }
                let mut vdata = vdata.unwrap();
                let ibytes = (isize::BITS/8) as usize;
                let bytelen = vdata.len();
                if ibytes > bytelen {
                    let irem = ibytes - bytelen;
                    for _i in 0..irem {
                        vdata.push(0);
                    }
                    return Ok(isize::from_ne_bytes(vdata.as_slice().try_into().unwrap()));
                } else {
                    return Err(format!("WARN:XOpData:GetISize:RandomBytes:Specified length {}, greater than int length {}", bytelen, ibytes));
                }
            }
            _ => { // All other XOps are str generating, so do the xop as part of get_string
                let sdata = self.get_string(ctxt);
                if sdata.is_err() {
                    return Err(format!("XOpData:GetISize:Casting:{:?}:{}", self, sdata.unwrap_err()));
                }
                let sdata = sdata.unwrap();
                let ival = Variant::StrValue(sdata).get_isize();
                if ival.is_err() {
                    return Err(format!("XOpData:GetISize:Converting:{:?}:{}", self, ival.unwrap_err()));
                }
                return Ok(ival.unwrap());
            }
        }
    }

    /// * XTimeStamp -> milliseconds from UnixEpoch, as the underlying byte values of the int
    /// * XRandomBytes returns random generated bytes
    pub fn get_bufvu8(&self, ctxt: &mut Context) -> Result<Vec<u8>, String> {
        match self {
            Self::ByteEle(dm, index) => {
                let i = index.get_usize(ctxt);
                if i.is_err() {
                    return Err(format!("XOpData:GetBuf:{:?}:Index:{}", self, i.unwrap_err()));
                }
                let bval = dm.get_byteelement(ctxt, i.unwrap());
                if bval.is_err() {
                    return Err(format!("XOpData:GetBuf:{:?}:{}", self, bval.unwrap_err()));
                }
                let mut bvec = Vec::new();
                bvec.push(bval.unwrap());
                return Ok(bvec);
            }
            Self::ArrayEle(ddm, idm) => {
                let i = idm.get_usize(ctxt);
                if i.is_err() {
                    return Err(format!("XOpData:GetBuf:{:?}:GetIndex:{}", self, i.unwrap_err()));
                }
                let vval = ddm.get_arrayelement(ctxt, i.unwrap());
                if vval.is_err() {
                    return Err(format!("XOpData:GetBuf:{:?}:IndexedData:{}", self, vval.unwrap_err()));
                }
                return Ok(vval.unwrap().get_bufvu8());
            }
            Self::TimeStamp => {
                let ts = time::SystemTime::now().duration_since(time::UNIX_EPOCH).unwrap();
                let uts = ts.as_millis();
                return Ok(uts.to_ne_bytes().to_vec());
            },
            Self::RandomBytes(bytelen) => {
                let mut rng = rand::thread_rng();
                let mut vdata: Vec<u8> = Vec::new();
                let bytelen = bytelen.get_usize(ctxt);
                if bytelen.is_err() {
                    return Err(format!("XOpData:GetBuf:{:?}:Bytelen:{}", self, bytelen.unwrap_err()));
                }
                let bytelen = bytelen.unwrap();
                for _i in 0..bytelen {
                    vdata.push(rng.gen_range(0..=255)); // rusty 0..256
                }
                return Ok(vdata);
            }
            _ => {
                // All other XOps are str generating, so do the xop as part of get_string
                let sdata = self.get_string(ctxt);
                if sdata.is_err() {
                    return Err(format!("XOpData:GetBuf:Casting:{:?}:{}", self, sdata.unwrap_err()));
                }
                return Ok(Variant::StrValue(sdata.unwrap()).get_bufvu8());
            }
        }
    }

    pub fn get_value(&self, ctxt: &mut Context) -> Result<Variant, String> {
        match self {
            Self::ByteEle(dm, index) => {
                let i = index.get_usize(ctxt);
                if i.is_err() {
                    return Err(format!("XOpData:GetValue:{:?}:Index:{}", self, i.unwrap_err()));
                }
                let bval = dm.get_byteelement(ctxt, i.unwrap());
                if bval.is_err() {
                    return Err(format!("XOpData:GetValue:{:?}:{}", self, bval.unwrap_err()));
                }
                return Ok(Variant::IntValue(bval.unwrap() as isize));
            }
            Self::ArrayEle(ddm, idm) => {
                let i = idm.get_usize(ctxt);
                if i.is_err() {
                    return Err(format!("XOpData:GetValue:{:?}:GetIndex:{}", self, i.unwrap_err()));
                }
                let vval = ddm.get_arrayelement(ctxt, i.unwrap());
                if vval.is_err() {
                    return Err(format!("XOpData:GetValue:{:?}:IndexedData:{}", self, vval.unwrap_err()));
                }
                return vval;
            }
            _ => {
                // All other XOps are str generating, so do the xop as part of get_string
                let sdata = self.get_string(ctxt);
                if sdata.is_err() {
                    return Err(format!("XOpData:GetValue:Casting:{:?}:{}", self, sdata.unwrap_err()));
                }
                return Ok(Variant::StrValue(sdata.unwrap()));
            }
        }
    }

    pub fn get_arrayelement(&self, ctxt: &mut Context, index: usize) -> Result<Variant, String> {
        match self {
            Self::ByteEle(_ddm, _idm) => {
                return Err(format!("XOpData:GetArrayEle:{:?}:Not allowed on a ByteEle", self));
            }
            Self::ArrayEle(ddm, idm) => {
                let i = idm.get_usize(ctxt);
                if i.is_err() {
                    return Err(format!("XOpData:GetArrayEle:{:?}:GetIndex:{}", self, i.unwrap_err()));
                }
                let vval = ddm.get_arrayelement(ctxt, i.unwrap());
                if vval.is_err() {
                    return Err(format!("XOpData:GetArrayEle:{:?}:IndexedData:{}", self, vval.unwrap_err()));
                }
                let rval = vval.unwrap().get_arrayelement(index);
                if rval.is_err() {
                    return Err(format!("XOpData:GetArrayEle:{:?}:Value:{}", self, rval.unwrap_err()));
                }
                return rval;
            }
            _ => {
                // All other XOps are str generating, so do the xop as part of get_string
                let sdata = self.get_string(ctxt);
                if sdata.is_err() {
                    return Err(format!("XOpData:GetArrayEle:Casting:{:?}:{}", self, sdata.unwrap_err()));
                }
                let rval = Variant::StrValue(sdata.unwrap()).get_arrayelement(index);
                if rval.is_err() {
                    return Err(format!("XOpData:GetArrayEle:Indexing:{:?}:{}", self, rval.unwrap_err()));
                }
                return rval;
            }
        }
    }

    pub fn get_type(&self, ctxt: &Context) -> VDataType {
        match self {
            Self::ByteEle(_,_) => return VDataType::Integer,
            Self::ArrayEle(ddm, _idm) => return ddm.get_type(ctxt),
            _ => return VDataType::String, // All other XOps are str generating, so this
        }
    }

}
